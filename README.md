# Draw.io C4 Diagram Parser Microservice

Этот проект представляет собой микросервис на Clojure для извлечения данных из C4-диаграмм, созданных в Draw.io (app.diagrams.net). Он предоставляет REST API для анализа XML-файлов и возвращает структурированные данные в формате JSON.

Сервис извлекает как явную информацию (элементы, связи), так и неявные иерархические связи, основанные на визуальном расположении элементов (вложенности).

## Table of Contents

- [Технологический стек](#технологический-стек)
- [Функциональность](#функциональность)
- [Конфигурация](#конфигурация)
- [Использование](#использование)
  - [Запуск через Docker (Рекомендуемый способ)](#запуск-через-docker-рекомендуемый-способ)
  - [Локальный запуск для разработки](#локальный-запуск-для-разработки)
- [REST API](#rest-api)
  - [POST /api/v1/parse/export](#post-apiv1parseexport)
  - [POST /api/v1/parse/paste](#post-apiv1parsepaste)
- [Структура выходных данных (JSON)](#структура-выходных-данных-json)
- [Критерии выявления неявных связей](#критерии-выявления-неявных-связей)

## Технологический стек

-   **Язык**: Clojure
-   **Веб-сервер**: http-kit
-   **Роутинг**: reitit
-   **Сборка**: clojure.tools.build
-   **Тестирование**: kaocha
-   **Контейнеризация**: Docker

## Функциональность

-   **REST API**: Предоставляет два эндпоинта для обработки разных форматов данных из Draw.io.
-   **Анализ геометрии**: Определяет вложенность элементов на основе их координат.
-   **Готовность к развертыванию**: Включает `Dockerfile` для легкой контейнеризации.

## Конфигурация

Сервис настраивается с помощью переменных о��ружения.

-   `DP_PORT`: Порт, на котором будет запущен веб-сервер.
    -   Для удобства локальной разработки можно создать файл `.env` в корне проекта:
        ```
        # .env
        DP_PORT=8080
        ```

## Использование

### Запуск через Docker (Рекомендуемый способ)

1.  **Сборка Docker-образа:**
    ```sh
    make docker-build
    ```

2.  **Запуск контейнера:**
    ```sh
    make docker-run
    ```
    Эта команда запустит контейнер, используя `DP_PORT` из вашего `.env` файла, проверит работоспособность API с помощью `curl` и остановит контейнер.

### Локальный запуск для разработки

1.  **Запуск тестов:**
    Тесты запускаются с помощью [Kaocha](https://github.com/lambdaisland/kaocha).
    ```sh
    make test
    ```

2.  **Запуск веб-сервера:**
    ```sh
    make run
    ```
    Сервер запустится на порту, указанном в `DP_PORT` (по умолчанию 8080).

## REST API

Полная спецификация API доступна в файле `openapi.yaml`.

### POST /api/v1/parse/export

Принимает стандартный XML-файл, экспортированный из Draw.io.

-   **URL**: `/api/v1/parse/export`
-   **Метод**: `POST`
-   **Headers**: `Content-Type: application/xml`
-   **Тело запроса**: Содержимое `.drawio` или `.xml` файла.
-   **Пример (cURL)**:
    ```sh
    curl -X POST --header "Content-Type: application/xml" \
         --data-binary "@resources/drawio.drawio.xml" \
         http://localhost:8080/api/v1/parse/export
    ```

### POST /api/v1/parse/paste

Принимает URL-encoded строку, скопированную из Draw.io через опцию "Extras -> Copy as Text".

-   **URL**: `/api/v1/parse/paste`
-   **Метод**: `POST`
-   **Headers**: `Content-Type: text/plain`
-   **Тело запроса**: URL-encoded строка.
-   **Пример (cURL)**:
    ```sh
    curl -X POST --header "Content-Type: text/plain" \
         --data-binary "@resources/drawio-paste.xml" \
         http://localhost:8080/api/v1/parse/paste
    ```

## Структура выходных данных (JSON)

Сервис возвращает JSON-объект, содержащий два ключа: `elements` и `relationships`.

```json
{
  "elements": [
    {
      "id": "container-5",
      "name": "API",
      "type": "Container",
      "description": null,
      "technology": "Clojure",
      "parent-id": "boundary-1"
    }
  ],
  "relationships": [
    {
      "id": "rel-10",
      "source": "user-id",
      "target": "container-5",
      "technology": "[JSON/HTTPS]"
    }
  ]
}
```

## Критерии выявления неявных связей

Неявная связь (принадлежность) определяется, когда один элемент визуально находится внутри другого. Для этого прямоугольник дочернего элемента должен быть **полностью** содержаться внутри прямоугольника родительского элемента, который должен иметь тип `SystemScopeBoundary` или `ContainerScopeBoundary`.

```